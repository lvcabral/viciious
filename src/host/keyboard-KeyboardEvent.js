import {
  eventToButtonNames     as eventToButtonNames_natural,
  keyStackToButtonNames  as keyStackToButtonNames_natural,
} from "./keyboard-natural";

import {
  eventToButtonNames     as eventToButtonNames_direct,
  keyStackToButtonNames  as keyStackToButtonNames_direct,
} from "./keyboard-direct";

import { buttonNameToMatrixPos } from "./buttonNameToMatrixPos";

// Bound by attach
let c64;

// Populated by setSetKeyMatrix;
let setKeyMatrix = () => {};

/*
   keyStack: an event stack that chronicles which C64 keyboard buttons (let's
   call them 'buttons' and those of host machine's, 'keys') got held down when.

   Example: if you were to hold down your Shift key, then your 8 key, keyStack
   would be:

      [
        { code: "Digit8", buttonCodes: [...] },
        { code: "ShiftLeft", buttonCodes: [...] }
      ]

   ...where buttonCodes is an array of names of C64 buttons (see
   buttonNameToMatrixPos) that corresponded to the keyboard event, and varies
   depending on the keyboard mapper used.

   The 'natural' keyboard mapping, for example, would have identified that the
   event that had the `code` of Digit8 was an asterisk press (in the case of a
   US keyboard); thus would record ["Asterisk"] in buttonCodes, whereas the
   'direct' keyboard mapping would record it as ["Num8"].

   When new keys are pressed, they're pushed/moved to the front of the stack.
   Released keys are removed from the stack.

   It's important to note that the `code` of the stack entries is the `code`
   field of a DOM keyboard event, and, in spite of the names of its values,
   represents the position of a key, not the symbol it represents. We use this
   position information for identifying, in the keyup, which stack entry was
   generated by the original keydown. Had we used `event.key` instead, keys
   would jam in cases like:

          (hold-shift, hold-R, release-shift, release-R)

   ...where the events we'll receive would have a keydown for "R", but a keyup
   for "r", and we'd be stuck with the "R" on the keyStack.
*/

let keyStack = [
  // {
  //   code
  //   buttonNames
  // }
];

function getEventToButtonNames() {
  return (
    c64.keyboard.naturalMapping
    ? eventToButtonNames_natural
    : eventToButtonNames_direct
  );
}

function getKeyStackToButtonNames() {
  return (
    c64.keyboard.naturalMapping
    ? keyStackToButtonNames_natural
    : keyStackToButtonNames_direct
  );
}


export function attach(nascentC64) {
  c64 = nascentC64;

  c64.keyboard = {
    setSetKeyMatrix,
    cursorsToKeys: true,
    naturalMapping: true,
  };

  globalThis.addEventListener("keydown", onKeyDown);
  globalThis.addEventListener("keyup",   onKeyUp);
  globalThis.addEventListener("blur",    onBlur);
}

// Called during initialization to tell the keyboard event handler how to send
// key matrices to CIA1.
export function setSetKeyMatrix(_setKeyMatrix) {
  setKeyMatrix = _setKeyMatrix;
}

function buttonNamesToKeyMatrix(buttonNames) {
  const keyMatrix = [0, 0, 0, 0, 0, 0, 0, 0];

  for (let buttonName of buttonNames) {
    const [column, row] = buttonNameToMatrixPos[buttonName];
    keyMatrix[column] |= (1 << row);
  }

  setKeyMatrix(keyMatrix);
}


function onKeyDown(event) {
  // Any keypress with the Meta key (cmd/ctrl/...) down isn't for us.
  if (event.metaKey) return;

  // Close Windows on Roku Back button
  if (event.code === "Escape") {
    console.log("Trying to close the Browser Window");
    window.close();
  }

  // Shift/Cursors may be disabled for keyboards so that they can go to the
  // joysticks only (otherwise games like Buggy Boy get stuck)
  if (!c64.keyboard.cursorsToKeys) {
    if (event.key === "Shift")      return;
    if (event.key === "ArrowUp")    return;
    if (event.key === "ArrowDown")  return;
    if (event.key === "ArrowLeft")  return;
    if (event.key === "ArrowRight") return;
  }

  // Map the event to a list of C64 buttons that the keypress corresponds to
  // (if any)
  const buttonNames = getEventToButtonNames()(event);
  if (!buttonNames) return;

  // For debug
  if (globalThis.inhibitKeyboard) return;

  // Associate the position-centric event.code with the names of the buttons it
  // translates to
  keyStack = [
    {
      code: event.code,
      buttonNames
    },
    ...keyStack.filter(
      ({ code }) => (code !== event.code)
    )
  ];

  // Make available to CIA1
  buttonNamesToKeyMatrix(
    getKeyStackToButtonNames()(keyStack)
  );

  event.preventDefault();
}

function onKeyUp(event) {
  const buttonNames = getEventToButtonNames()(event);
  if (!buttonNames) return;

  keyStack = keyStack.filter(
    ({ code }) => (code !== event.code)
  );

  buttonNamesToKeyMatrix(
    getKeyStackToButtonNames()(keyStack)
  );

  event.preventDefault();
}

function onBlur(event) {
  // All bets are off when we lose focus. So assume all keys got released.
  keyStack = [];
  buttonNamesToKeyMatrix([]);
}
